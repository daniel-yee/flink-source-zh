### State存储

当使用MemoryStateBackend和FsStateBackend时，默认情况下会将状态数据保存到CopyOnWriteStateTable中，它是StateTable
接口的一个实现，其中可以保存多个KeyGroup的状态，每个KeyGroup对应一个CopyOnWriteStateMap。

CopyOnWriteStateMap的结构类似于HashMap，但是它相比于HashMap支持了两个特别有意思的功能：
  * 哈希结构为了保证数据读写的效率都会有宇哥扩容策略，CopyOnWriteStateMap采用的是渐进式rehash策略，它不会一次性将所有数
  据都迁移到新的hash表，二是会逐渐的将数据迁移过去;
  
  * 支持checkpoint时的异步快照，可以在快照的同时对其中的数据执行修改操作，并能同时保证快照数据的准确性;

MemoryStateBackend和FsStateBackend的KeyedStateBackend都使用HeapKeyedStateBackend存储数据，HeapKeyedStateBackend
持有Map<String, StateTable<K, ?, ?>> registeredKVStates来存储StateName与具体State的映射关系。registeredKVStates的
key就是StateName，value是具体的State数据，value存储在StateTable中。

StateTable有两种实现：
  * CopyOnWriteStateTable属于Flink定制化的数据结构，在进行checkpoint时支持异步快照;
  * NestedMapStateTable直接使用嵌套的双层HashMap存储数据，在进行checkpoint时只能进行同步快照;

下面主要就CopyOnWriteStateTable类进行介绍。在StateTable中持有StateMap[] keyGroupedStateMaps真正的存储数据。StateTable
会为每个KeyGroup的数据都初始化一个StateMap来对KeyGroup做数据隔离。在对状态进行操作时，它会先根据Key找到对应的KeyGroup，从而拿
到相应的StateMap，这样才能对状态进行操作。而在CopyOnWriteStateTable中就使用CopyOnWriteStateMap存储数据，这是一个数组+链表构
成的Hash表，其中的数据类型都是StateMapEntry。Hash表的第一层是一个StateMapEntry类型的数组，也就是StateMapEntry[]。在StateMapEntry
类中有一个StateMapEntry next指针构成的链表。

先来介绍下CopyOnWriteStateMap类的渐进式rehash策略，它其中有一个hash表堆外提供服务，但是如果表中的元素太多需要扩容时，就需要将数
据迁移到一个容量更大的hash表中去。在Java的HashMap扩容时，会将旧Hash表中的所有数据一次性的都移动到大Hash表中，这样的策略存在一定的
问题：如果当前HashMap中已经存储了1G的数据，那么就需要将1G的数据一次迁移完成，这个过程可能会比较耗时。而CopyOnWriteStateMap在扩容
时，则不会一次将数据全部迁移，而是在每次操作它时慢慢的将数据迁移到大的Hash表中。

